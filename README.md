# Задача
Даны прямоугольники на плоскости с углами в целочисленных координатах ([1..109],[1..109]). Требуется как можно быстрее выдавать ответ на вопрос «Скольким прямоугольникам принадлежит точка (x,y)?» Подготовка данных должна занимать мало времени. Примечание: только нижние границы включены => (x1<= x) && (x<x2) && (y1<=y) && (y<y2)

# Файлы с исходным кодом:
Реализация алгоритма перебора - https://github.com/Juliia228/laba/blob/master/src/src/BruteForce.java

Реализация алгоритма на карте - https://github.com/Juliia228/laba/blob/master/src/src/WithMap.java

Реализация алгоритма на дереве - https://github.com/Juliia228/laba/blob/master/src/src/PersistentSegmentTree.java

Код создания тестов - https://github.com/Juliia228/laba/blob/master/src/src/TestData.java

Код запуска тестов - https://github.com/Juliia228/laba/blob/master/src/src/Main.java

# Тестирование
Для тестирования каждого алгоритма было использовано 2^i прямоугольников (0<=i<=12) и 100000 точек для каждого набора прямоугольников. Для тестового набора прямоугольников был использован набор вложенных друг в друга прямоугольников с координатами с шагом больше 1: {(10 * i, 10 * i), (10 * (2N - i), 10 * (2N - i))}. Для тестового набора точек был использован неслучайный набор распределенных равномерно по ненулевому пересечению прямоугольников: хэш функции от i с разным базисом для x и y ((p * i) ^ 31 % (20 * N), p - большое простое, разное для x и y).

Результаты тестов - https://github.com/Juliia228/laba/tree/master/src/tests

# Выводы
*Примечание:* оси в графиках - логарифмические
## Время подготовки 
![image](https://user-images.githubusercontent.com/98903090/236572624-7c774ede-e824-4287-8d62-18b0bf972297.png)
Подготовка для алгоритма перебора (Brute Force) не производится, поэтому данных о ней нет на графике. Для алгоритма на карте (Map) строится карта, построение которой выполняется за O(n^3). В случае с деревом отрезков (Persistent Segment Tree), данная структура строится за O(n * log(n)). Из графика видно, что время построения карты растет быстрее, чем время построения дерева. При этом на маленьких данных карта строится быстрее дерева, а на больших - медленнее.


## Время получения ответа для точек
![image](https://user-images.githubusercontent.com/98903090/236572839-52911923-41ad-438a-bedf-c10e26670e31.png)
Из графика видно, что алгоритмы на карте и на дереве получают ответы для точек примерно за одинаковое время, их асимптотическая сложность равна O(log(n)). В то время как алгоритм перебора требует больше времени - O(n). На графике это отражено, алгоритм перебора почти всегда выше остальных, особенно на больших данных, поэтому для получения ответов для точек он является наименее эффективным. На минимальных входных данных видна погрешность результатов - время выполнения довольно большое для таких значений. Это может быть связано с особенностями локальной машины, на которой воспроизводились тесты.

## Общее время работы алгоритмов
![image](https://user-images.githubusercontent.com/98903090/236573168-8705c78a-0da3-46b0-aec9-27afd071aa8c.png)
Из графика видно, что на значениях до n=128 полное время работы всех алгоритмов почти одинаковое. Однако на больших данных разница хорошо видна. Алгоритм на карте сильно уступает двум другим, так как тратит много времени на построение самой карты. На протяжении почти всего графика алгоритм перебора все же находится выше других. Начиная с n=1024, время работы алгоритма на карте сильно превосходит время работы алгоритма перебора. 

Итак, на маленьких данных самым неэффективным является алгоритм перебора. Несмотря на то, что ему не нужно время на подготовку, много времени уходит на поиск ответов для точек. На больших данных наименее эффективен алгоритм на карте, так как построение карты занимает очень много времени. Алгоритм на дереве отрезков является самым эффективным, поскольку почти на всех данных тратит меньше всего времени. 
